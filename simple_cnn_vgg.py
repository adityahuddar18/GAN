# -*- coding: utf-8 -*-
"""Simple_cnn_vgg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nkGJooonVWgV_3U5-AYVGp7mIafZEqn2
"""



#main
from google.colab import drive
drive.mount('/content/drive')

##main
import os
import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.optimizers import Adam

# Define paths
base_dir = '/content/drive/MyDrive/10sample'

# Data Augmentation and Data Loading
datagen = ImageDataGenerator(
    rescale=1./255,  # Normalize pixel values
    validation_split=0.2  # 20% of data for validation
)

train_generator = datagen.flow_from_directory(
    base_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical',
    subset='training'
)

validation_generator = datagen.flow_from_directory(
    base_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical',
    subset='validation'
)

# Build the CNN model
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)),
    MaxPooling2D((2, 2)),

    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),

    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),

    Flatten(),
    Dense(512, activation='relu'),
    Dropout(0.5),
    Dense(3, activation='softmax')
])

# Compile the model
model.compile(
    optimizer=Adam(),
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# Train the model
history = model.fit(
    train_generator,
    steps_per_epoch=train_generator.samples // train_generator.batch_size,
    epochs=10,
    validation_data=validation_generator,
    validation_steps=validation_generator.samples // validation_generator.batch_size
)

# Evaluate the model
loss, accuracy = model.evaluate(validation_generator)
print(f'Validation Loss: {loss}')
print(f'Validation Accuracy: {accuracy}')

# Save the model
model.save('basic_cnn_model_4_classes.h5')

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model('/content/basic_cnn_model_4_classes.h5')

# Define the path to the image you want to predict
image_path = '/content/drive/MyDrive/10sample/p/30462085_aug_15.jpg'

# Load and preprocess the image
img = image.load_img(image_path, target_size=(150, 150))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize pixel values

# Predict the class probabilities
predictions = model.predict(img_array)
predicted_class_index = np.argmax(predictions, axis=1)[0]

# Map the class index to the class label
class_labels = list(train_generator.class_indices.keys())
predicted_class_label = class_labels[predicted_class_index]

# Print the result
print(f'The image is predicted to be of class: {predicted_class_label}')

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model('/content/basic_cnn_model_4_classes.h5')

# Define the path to the image you want to predict
image_path = '/content/drive/MyDrive/10sample/pom/Copy of One_1703211006337_aug_11.jpg'

# Load and preprocess the image
img = image.load_img(image_path, target_size=(150, 150))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize pixel values

# Predict the class probabilities
predictions = model.predict(img_array)
predicted_class_index = np.argmax(predictions, axis=1)[0]

# Map the class index to the class label
class_labels = list(train_generator.class_indices.keys())
predicted_class_label = class_labels[predicted_class_index]

# Print the result
print(f'The image is predicted to be of class: {predicted_class_label}')

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model('/content/basic_cnn_model_4_classes.h5')

# Define the path to the image you want to predict
image_path = '/content/drive/MyDrive/10sample/pop/Copy of One_1703231271132_aug_13.jpg'

# Load and preprocess the image
img = image.load_img(image_path, target_size=(150, 150))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize pixel values

# Predict the class probabilities
predictions = model.predict(img_array)
predicted_class_index = np.argmax(predictions, axis=1)[0]

# Map the class index to the class label
class_labels = list(train_generator.class_indices.keys())
predicted_class_label = class_labels[predicted_class_index]

# Print the result
print(f'The image is predicted to be of class: {predicted_class_label}')

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model('/content/basic_cnn_model_4_classes.h5')

# Define the path to the image you want to predict
image_path = '/content/drive/MyDrive/10sample/p/30462160_aug_1.jpg'

# Load and preprocess the image
img = image.load_img(image_path, target_size=(150, 150))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize pixel values

# Predict the class probabilities
predictions = model.predict(img_array)
predicted_class_index = np.argmax(predictions, axis=1)[0]

# Map the class index to the class label
class_labels = list(train_generator.class_indices.keys())
predicted_class_label = class_labels[predicted_class_index]

# Print the result
print(f'The image is predicted to be of class: {predicted_class_label}')

from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Define the base directory containing the images
base_dir = '/content/drive/MyDrive/10sample'

# Define the data augmentation and normalization for training
train_datagen = ImageDataGenerator(
    rescale=1.0/255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest',
    validation_split=0.2  # Specify the validation split
)

# Define the data augmentation and normalization for validation
val_datagen = ImageDataGenerator(
    rescale=1.0/255,
    validation_split=0.2  # Specify the validation split
)

# Create training and validation generators
train_generator = train_datagen.flow_from_directory(
    base_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical',
    subset='training'  # Set to 'training' subset
)

validation_generator = val_datagen.flow_from_directory(
    base_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical',
    subset='validation'  # Set to 'validation' subset
)

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model('/content/basic_cnn_model_4_classes.h5')

# Define the path to the image you want to predict
image_path = '/content/drive/MyDrive/10sample/p/30462160_aug_1.jpg'

# Load and preprocess the image
img = image.load_img(image_path, target_size=(150, 150))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize pixel values

# Predict the class probabilities
predictions = model.predict(img_array)
predicted_class_index = np.argmax(predictions, axis=1)[0]

# Map the class index to the class label
class_labels = list(train_generator.class_indices.keys())
predicted_class_label = class_labels[predicted_class_index]

# Print the result
print(f'The image is predicted to be of class: {predicted_class_label}')

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Assuming the model is already defined and compiled
# model = ...

# Define the ImageDataGenerator for testing or validation
base_dir = '/content/drive/MyDrive/10sample'  # Update with your dataset path
datagen = ImageDataGenerator(rescale=1.0/255)

test_generator = datagen.flow_from_directory(
    base_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical'
)

# Evaluate the model
loss, accuracy = model.evaluate(test_generator)
print(f'Test Accuracy: {accuracy * 100:.2f}%')

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model('/content/basic_cnn_model_4_classes.h5')

# Define the path to the image you want to predict
image_path = '/content/drive/MyDrive/10sample/p/30462085.jpg'

# Load and preprocess the image
img = image.load_img(image_path, target_size=(150, 150))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize pixel values

# Predict the class probabilities
predictions = model.predict(img_array)
predicted_class_index = np.argmax(predictions, axis=1)[0]

# Map the class index to the class label
class_labels = list(train_generator.class_indices.keys())
predicted_class_label = class_labels[predicted_class_index]

# Print the result
print(f'The image is predicted to be of class: {predicted_class_label}')

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model('/content/basic_cnn_model_4_classes.h5')

# Define the path to the image you want to predict
image_path = '/content/drive/MyDrive/10sample/pom/Copy of One_1703072949328.jpg'

# Load and preprocess the image
img = image.load_img(image_path, target_size=(150, 150))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize pixel values

# Predict the class probabilities
predictions = model.predict(img_array)
predicted_class_index = np.argmax(predictions, axis=1)[0]

# Map the class index to the class label
class_labels = list(train_generator.class_indices.keys())
predicted_class_label = class_labels[predicted_class_index]

# Print the result
print(f'The image is predicted to be of class: {predicted_class_label}')

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model('/content/basic_cnn_model_4_classes.h5')

# Define the path to the image you want to predict
image_path = '/content/drive/MyDrive/10sample/pop/Copy of One_1703231271132_aug_32.jpg'

# Load and preprocess the image
img = image.load_img(image_path, target_size=(150, 150))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize pixel values

# Predict the class probabilities
predictions = model.predict(img_array)
predicted_class_index = np.argmax(predictions, axis=1)[0]

# Map the class index to the class label
class_labels = list(train_generator.class_indices.keys())
predicted_class_label = class_labels[predicted_class_index]

# Print the result
print(f'The image is predicted to be of class: {predicted_class_label}')

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load the trained model
model = load_model('/content/basic_cnn_model_4_classes.h5')

# Define the path to the image you want to predict
image_path = ''

# Load and preprocess the image
img = image.load_img(image_path, target_size=(150, 150))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize pixel values

# Predict the class probabilities
predictions = model.predict(img_array)
predicted_class_index = np.argmax(predictions, axis=1)[0]

# Map the class index to the class label
class_labels = list(train_generator.class_indices.keys())
predicted_class_label = class_labels[predicted_class_index]

# Print the result
print(f'The image is predicted to be of class: {predicted_class_label}')

import tensorflow as tf
from tensorflow.keras.callbacks import Callback
import numpy as np

class PredictOriginalImagesCallback(Callback):
    def __init__(self, original_image_paths, labels, model_input_size):
        super().__init__()
        self.original_image_paths = original_image_paths
        self.labels = labels
        self.model_input_size = model_input_size

    def preprocess_image(self, image_path):
        img = cv2.imread(image_path)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        img = cv2.resize(img, self.model_input_size)
        img = img / 255.0
        img = np.expand_dims(img, axis=0)
        return img

    def on_epoch_end(self, epoch, logs=None):
        correct_predictions = 0
        total_predictions = len(self.original_image_paths)

        for idx, image_path in enumerate(self.original_image_paths):
            img = self.preprocess_image(image_path)
            prediction = self.model.predict(img)
            predicted_class = np.argmax(prediction)
            true_class = self.labels[idx]
            if predicted_class == true_class:
                correct_predictions += 1

        accuracy = correct_predictions / total_predictions
        print(f'Accuracy on original images at epoch {epoch}: {accuracy:.2f}')

# Define your original image paths and their labels
original_image_paths = [
    'path/to/original_image1.jpg',
    '/content/drive/MyDrive/10sample/pom/Copy of One_1703072949328_aug_33.jpg',
    # Add paths to all your original images
]
labels = [
    0,  # Corresponding class label for original_image1
    1,  # Corresponding class label for original_image2
    2,
    3# Add corresponding labels for all your original images
]

model_input_size = (150, 150)  # Change this to match your model's input size

# Create an instance of the callback
original_images_callback = PredictOriginalImagesCallback(original_image_paths, labels, model_input_size)

# Assuming 'model' is your Keras model and 'train_generator' is your data generator
history = model.fit(
    train_generator,
    epochs=10,
    validation_data=validation_generator,
    callbacks=[original_images_callback]
)

import tensorflow as tf
from tensorflow.keras.callbacks import Callback
import numpy as np

class PredictOriginalImagesCallback(Callback):
    def __init__(self, original_image_paths, labels, model_input_size):
        super().__init__()
        self.original_image_paths = original_image_paths
        self.labels = labels
        self.model_input_size = model_input_size

    def preprocess_image(self, image_path):
        img = cv2.imread(image_path)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        img = cv2.resize(img, self.model_input_size)
        img = img / 255.0
        img = np.expand_dims(img, axis=0)
        return img

    def on_epoch_end(self, epoch, logs=None):
        correct_predictions = 0
        total_predictions = len(self.original_image_paths)

        for idx, image_path in enumerate(self.original_image_paths):
            img = self.preprocess_image(image_path)
            prediction = self.model.predict(img)
            predicted_class = np.argmax(prediction)
            true_class = self.labels[idx]
            if predicted_class == true_class:
                correct_predictions += 1

        accuracy = correct_predictions / total_predictions
        print(f'Accuracy on original images at epoch {epoch}: {accuracy:.2f}')

# Define your original image paths and their labels
original_image_paths = [
    'path/to/original_image1.jpg',
    'path/to/original_image2.jpg',
    # Add paths to all your original images
]
labels = [
    0,  # Corresponding class label for original_image1
    1,  # Corresponding class label for original_image2
    # Add corresponding labels for all your original images
]

model_input_size = (150, 150)  # Change this to match your model's input size

# Create an instance of the callback
original_images_callback = PredictOriginalImagesCallback(original_image_paths, labels, model_input_size)

# Assuming 'model' is your Keras model and 'train_generator' is your data generator
history = model.fit(
    train_generator,
    epochs=10,
    validation_data=validation_generator,
    callbacks=[original_images_callback]
)

pip install gradio

#!pip install gradio
import gradio as gra
def user_greeting(name):
    return "Hi! " + name + " Welcome to your first Gradio application!😎"

#define gradio interface and other parameters
app =  gra.Interface(fn = user_greeting, inputs="text", outputs="text")
app.launch()

import tensorflow as tf
import numpy as np
import cv2
import gradio as gr

# Load the trained model
model = tf.keras.models.load_model('/content/basic_cnn_model_4_classes.h5')

# Class labels
class_labels = ['p', 'pom', 'pop']

# Prediction function
def predict_image(image):
    # Preprocess the image
    img = cv2.resize(image, (64, 64))  # Resize to the input shape your model expects
    img = img / 255.0  # Normalize the image
    img = np.expand_dims(img, axis=0)  # Add batch dimension

    # Make prediction
    predictions = model.predict(img)
    predicted_class = class_labels[np.argmax(predictions)]

    return predicted_class

# Gradio interface
interface = gr.Interface(
    fn=predict_image,
    inputs=gr.Image(type="numpy", label="Upload an Image"),
    outputs=gr.Textbox(label="Predicted Class"),
    title="Simple CNN Image Classifier",
    description="Upload an image to get the predicted class.",
)

# Launch the interface
interface.launch()

## main

import tensorflow as tf
import numpy as np
import cv2
import gradio as gr

# Load the trained model
model = tf.keras.models.load_model('/content/basic_cnn_model_4_classes.h5')

# Class labels (including an empty class)
class_labels = ['p', 'pom', 'pop']

# Prediction function
def predict_image(image):
    try:
        # Preprocess the image
        img = cv2.resize(image, (150, 150))  # Resize to the input shape your model expects
        img = img / 255.0  # Normalize the image
        img = np.expand_dims(img, axis=0)  # Add batch dimension

        # Make prediction
        predictions = model.predict(img)
        predicted_class = class_labels[np.argmax(predictions)]

        return predicted_class
    except Exception as e:
        return str(e)

# Gradio interface
interface = gr.Interface(
    fn=predict_image,
    inputs=gr.Image(type="numpy", label="Upload an Image"),
    outputs=gr.Textbox(label="Predicted Class"),
    title="Simple CNN Image Classifier",
    description="Upload an image to get the predicted class.",
)

# Launch the interface
interface.launch()

pip install --upgrade gradio

import random

def random_response(message, history):
    return random.choice(["Yes", "No"])
    import gradio as gr

gr.ChatInterface(random_response).launch()

# Save the model to Google Drive
model.save('/content/basic_cnn_model_4_classes.h5')

# Load the model from Google Drive
from google.colab import drive
drive.mount('/content/drive')

import tensorflow as tf
model = tf.keras.models.load_model('/content/basic_cnn_model_4_classes.h5')
model.summary()

from google.colab import drive
import tensorflow as tf
import os

# Mount Google Drive
drive.mount('/content/drive')

# Save the model to Google Drive
model.save('/content/basic_cnn_model_4_classes.h5')

# Verify the file exists
file_path = '/content/drive/MyDrive/validation/p'
if os.path.exists(file_path):
    print(f"The file {file_path} exists.")
else:
    print(f"The file {file_path} does not exist.")

import shutil

# Source path
src_path = '/content/basic_cnn_model_4_classes.h5'

# Destination path
dest_path = '/content/drive/MyDrive/basic_cnn_model_4_classes.h5'

# Copy the model to Google Drive
shutil.copy(src_path, dest_path)

print(f"Model saved to {dest_path}")

